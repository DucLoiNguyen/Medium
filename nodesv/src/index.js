import express from 'express';
import morgan from 'morgan';
import http from 'http';
import dotenv from 'dotenv';
import route from './routes/index.js';
import connect from './config/db.js';
import cors from 'cors';
import path from 'path';
import { fileURLToPath } from 'url';
import multer from 'multer';
import session from 'express-session';
import stripePackage from 'stripe';
import User from './models/UserModel.js';
import { Server } from 'socket.io';
import EmailController from './controllers/EmailController.js';
import cron from 'node-cron';

dotenv.config();
const port = process.env.PORT;
const stripe = stripePackage('sk_test_51R2PhKPH7d6YNyhMVHxCw8sHlLZkTU8q17kLyqb4glmW2gRdriggjJPxgFEJWJKNACF5bv5S6kQkoiR9VpaYIacG006WLoBZay');

const app = express();
const server = http.createServer(app);
const sessionMiddleware = session({
    secret: 'my_flower',
    resave: false,
    saveUninitialized: false,
    cookie: { secure: false, httpOnly: true, maxAge: 3600000 }
});

const io = new Server(server, {
    cors: { origin: 'http://localhost:8080', credentials: true, methods: ['GET', 'POST'] }
});

app.use(( req, res, next ) => {
    req.io = io;
    next();
});

io.on('connection', ( socket ) => {
    console.log('User connected:', socket.id);

    // Khi user ƒëƒÉng nh·∫≠p, join v√†o room ri√™ng
    socket.on('authenticate', ( userId ) => {
        socket.join(userId.toString());
        console.log(`User ${ userId } joined room`);
    });

    socket.emit('test', { test: 'test' });

    socket.on('disconnect', () => {
        console.log('User disconnected:', socket.id);
    });
});


const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

app.use(express.static(path.join(__dirname, 'uploads')));
app.use(cors({
    origin: 'http://localhost:8080',
    credentials: true
}));
app.use(morgan('combined'));

// C·∫•u h√¨nh multer ƒë·ªÉ x·ª≠ l√Ω file upload
const storage = multer.diskStorage({
    destination: function ( req, file, cb ) {
        cb(null, 'src/uploads/images'); // Th∆∞ m·ª•c l∆∞u ·∫£nh upload
    },
    filename: function ( req, file, cb ) {
        cb(null, Date.now() + '-' + file.originalname); // ƒê·∫∑t t√™n file ƒë·ªÉ tr√°nh tr√πng l·∫∑p
    }
});

// Ki·ªÉm tra lo·∫°i file
const fileFilter = ( req, file, cb ) => {
    const allowedTypes = ['image/jpeg', 'image/jpg', 'image/png', 'image/gif'];
    if ( allowedTypes.includes(file.mimetype) ) {
        cb(null, true);
    } else {
        cb(new Error('Ch·ªâ ch·∫•p nh·∫≠n file ·∫£nh!'), false);
    }
};

const upload = multer({
    storage: storage,
    limits: { fileSize: 1024 * 1024 * 50 }, // Gi·ªõi h·∫°n k√≠ch th∆∞·ªõc file: 5MB
    fileFilter: fileFilter
});

app.post('/webhook', express.raw({ type: 'application/json' }), async ( req, res ) => {
    const sig = req.headers['stripe-signature'];
    let event;

    try {
        event = stripe.webhooks.constructEvent(
            req.body,
            sig,
            process.env.STRIPE_WEBHOOK_SECRET
        );
    } catch ( err ) {
        console.error(`Webhook Error: ${ err.message }`);
        return res.status(400).send(`Webhook Error: ${ err.message }`);
    }

    // X·ª≠ l√Ω c√°c s·ª± ki·ªán t·ª´ Stripe
    try {
        switch ( event.type ) {
            case 'invoice.payment_succeeded':
                // C·∫≠p nh·∫≠t ng√†y h·∫øt h·∫°n khi thanh to√°n th√†nh c√¥ng
                const invoice = event.data.object;
                if ( invoice.subscription ) {
                    const subscription = await stripe.subscriptions.retrieve(invoice.subscription);
                    await User.updateOne(
                        { stripeCustomerId: invoice.customer },
                        {
                            subscriptionEndDate: new Date(subscription.current_period_end * 1000),
                            isMember: true,
                            subscriptionStatus: subscription.status
                        }
                    );
                    console.log(`‚úÖ Updated subscription for customer ${ invoice.customer } after payment success`);
                }
                break;

            case 'invoice.payment_failed':
                // X·ª≠ l√Ω thanh to√°n th·∫•t b·∫°i
                const failedInvoice = event.data.object;
                if ( failedInvoice.subscription ) {
                    const user = await User.findOne({ stripeCustomerId: failedInvoice.customer });
                    if ( user ) {
                        await EmailController.sendPaymentFailureNotification({
                            email: user.email,
                            username: user.username
                        });
                        console.log(`üìß Sent payment failure email to ${ user.email }`);
                    }
                }
                break;

            case 'customer.subscription.deleted':
                // Subscription b·ªã x√≥a (h·∫øt h·∫°n ho·∫∑c b·ªã h·ªßy)
                const deletedSubscription = event.data.object;
                await User.updateOne(
                    { stripeCustomerId: deletedSubscription.customer },
                    { isMember: false, subscriptionStatus: 'inactive' }
                );
                console.log(`‚ùå Marked subscription as inactive for customer ${ deletedSubscription.customer }`);
                break;

            case 'customer.subscription.updated':
                // Subscription ƒë∆∞·ª£c c·∫≠p nh·∫≠t
                const updatedSubscription = event.data.object;
                await User.updateOne(
                    { stripeCustomerId: updatedSubscription.customer },
                    {
                        subscriptionEndDate: new Date(updatedSubscription.current_period_end * 1000),
                        subscriptionStatus: updatedSubscription.status
                    }
                );
                console.log(`üìù Updated subscription details for customer ${ updatedSubscription.customer }`);
                break;

            case 'customer.subscription.trial_will_end':
                // Th√¥ng b√°o tr∆∞·ªõc khi k·∫øt th√∫c th·ªùi gian d√πng th·ª≠ (n·∫øu c√≥)
                const trialEndSubscription = event.data.object;
                const trialEndUser = await User.findOne({ stripeCustomerId: trialEndSubscription.customer });
                if ( trialEndUser ) {
                    await EmailController.sendTrialEndingSoon({
                        email: trialEndUser.email,
                        username: trialEndUser.username,
                        endDate: new Date(trialEndSubscription.trial_end * 1000)
                    });
                }
                break;

            default:
                console.log(`Unhandled event type: ${ event.type }`);
        }
    } catch ( error ) {
        console.error(`Error processing webhook event ${ event.type }:`, error);
        // Kh√¥ng tr·∫£ l·ªói 500 cho Stripe, v√¨ n√≥ s·∫Ω th·ª≠ l·∫°i s·ª± ki·ªán
        // Thay v√†o ƒë√≥, ch√∫ng ta ghi log v√† v·∫´n tr·∫£ v·ªÅ th√†nh c√¥ng
    }

    // Tr·∫£ v·ªÅ th√†nh c√¥ng ƒë·ªÉ Stripe bi·∫øt r·∫±ng ch√∫ng ta ƒë√£ nh·∫≠n ƒë∆∞·ª£c s·ª± ki·ªán
    res.json({ received: true });
});

app.use(express.json({ limit: '100mb' }));
app.use(express.urlencoded({ limit: '100mb', extended: true }));
app.use(sessionMiddleware);

// API endpoint ƒë·ªÉ upload ·∫£nh
app.post('/api/upload', upload.single('image'), ( req, res ) => {
    try {
        if ( !req.file ) {
            // return res.status(400).json({ message: 'Vui l√≤ng ch·ªçn file ·∫£nh!' });
            return;
        }

        // Tr·∫£ v·ªÅ ƒë∆∞·ªùng d·∫´n c·ªßa ·∫£nh ƒë√£ upload
        res.status(200).json({
            message: 'Upload th√†nh c√¥ng!',
            filePath: `/images/${ req.file.filename }`
        });
    } catch ( error ) {
        res.status(500).json({
            message: 'C√≥ l·ªói khi upload ·∫£nh!',
            error: error.message
        });
    }
});

// API endpoint ƒë·ªÉ l·∫•y danh s√°ch ·∫£nh ƒë√£ upload
app.get('/api/images', ( req, res ) => {
    try {
        const files = fs.readdirSync(uploadDir);
        const images = files.map(file => ( {
            name: file,
            path: `/uploads/${ file }`,
            url: `http://localhost:${ PORT }/${ file }`
        } ));

        res.status(200).json(images);
    } catch ( error ) {
        res.status(500).json({
            message: 'L·ªói khi l·∫•y danh s√°ch ·∫£nh',
            error: error.message
        });
    }
});

// T·∫°o phi√™n thanh to√°n v·ªõi Stripe
app.post('/create-subscription', async ( req, res ) => {
    try {
        const { email, paymentMethodId } = req.body;
        let user = await User.findOne({ email });

        if ( !user ) {
            const customer = await stripe.customers.create({
                email,
                payment_method: paymentMethodId,
                invoice_settings: { default_payment_method: paymentMethodId }
            });
            user = await User.create({ email, stripeCustomerId: customer.id });
        }

        if ( !user.stripeCustomerId ) {
            const customer = await stripe.customers.create({
                email,
                payment_method: paymentMethodId,
                invoice_settings: { default_payment_method: paymentMethodId },
            });

            // C·∫≠p nh·∫≠t stripeCustomerId v√†o database
            user.stripeCustomerId = customer.id;
            await user.save();
        }

        const subscription = await stripe.subscriptions.create({
            customer: user.stripeCustomerId,
            items: [{ price: 'price_1R2kvbPH7d6YNyhMPjmmP4bl' }], // ID c·ªßa g√≥i subscription tr√™n Stripe
            expand: ['latest_invoice.payment_intent'],
        });

        // L∆∞u th√¥ng tin subscription
        await User.updateOne(
            { email },
            {
                isMember: true,
                subscriptionId: subscription.id,
                subscriptionStatus: 'active',
                subscriptionEndDate: new Date(subscription.current_period_end * 1000) // Chuy·ªÉn timestamp sang Date
            }
        );

        req.session.user.isMember = true;

        await EmailController.sendRegistrationConfirmation({
            email: req.session.user.email,
            username: req.session.user.username,
            subscriptionEndDate: new Date(subscription.current_period_end * 1000)
        });

        res.json({
            message: 'Subscription successful',
            subscriptionId: subscription.id,
            currentPeriodEnd: new Date(subscription.current_period_end * 1000)
        });
    } catch ( error ) {
        res.status(500).json({ error: error.message });
    }
});

// Route ƒë·ªÉ h·ªßy ƒëƒÉng k√Ω nh∆∞ng v·∫´n duy tr√¨ ƒë·∫øn khi h·∫øt chu k·ª≥
app.post('/cancel-subscription', async ( req, res ) => {
    try {
        const { email } = req.body;

        // T√¨m user theo email
        const user = await User.findOne({ email });
        if ( !user?.stripeCustomerId || !user?.subscriptionId ) {
            return res.status(404).json({ error: 'User not found or not subscribed' });
        }

        // H·ªßy subscription nh∆∞ng ƒë·∫∑t cancel_at_period_end th√†nh true ƒë·ªÉ duy tr√¨ ƒë·∫øn khi h·∫øt chu k·ª≥
        const subscription = await stripe.subscriptions.update(user.subscriptionId, {
            cancel_at_period_end: true
        });

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i subscription trong database
        await User.updateOne(
            { email },
            {
                // Kh√¥ng c·∫≠p nh·∫≠t isMember th√†nh false ngay,
                // v√¨ ng∆∞·ªùi d√πng v·∫´n l√† th√†nh vi√™n cho ƒë·∫øn khi h·∫øt h·∫°n
                subscriptionStatus: 'canceled',
                // V·∫´n gi·ªØ subscriptionEndDate ƒë·ªÉ bi·∫øt khi n√†o subscription th·ª±c s·ª± k·∫øt th√∫c
            }
        );

        await EmailController.sendAccountCancellationConfirmation({
            email: req.session.user.email,
            username: req.session.user.username,
            endDate: new Date(subscription.current_period_end * 1000) // Th√™m ng√†y k·∫øt th√∫c v√†o email
        });

        res.json({
            message: 'Subscription canceled successfully. Membership will remain active until the end of the billing period.',
            endDate: new Date(subscription.current_period_end * 1000)
        });

    } catch ( error ) {
        console.error('‚ùå Error canceling subscription:', error);
        res.status(500).json({ error: error.message });
    }
});

// Ch·∫°y m·ªói ng√†y l√∫c n·ª≠a ƒë√™m
cron.schedule('0 0 * * *', async () => {
    console.log('Running membership status check cron job...');
    await checkAndUpdateMembershipStatus();
});

// Task ƒë·ªãnh k·ª≥ ƒë·ªÉ ki·ªÉm tra v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i membership
async function checkAndUpdateMembershipStatus() {
    const now = new Date();

    // T√¨m t·∫•t c·∫£ ng∆∞·ªùi d√πng c√≥ subscription ƒë√£ h·∫øt h·∫°n
    const usersToUpdate = await User.find({
        isMember: true,
        subscriptionStatus: 'canceled',
        subscriptionEndDate: { $lt: now }
    });

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh vi√™n
    for ( const user of usersToUpdate ) {
        await User.updateOne(
            { _id: user._id },
            { isMember: false, subscriptionStatus: 'inactive' }
        );

        // G·ª≠i email th√¥ng b√°o membership ƒë√£ k·∫øt th√∫c
        await EmailController.sendMembershipEndedNotification({
            email: user.email,
            username: user.username
        });
    }

    console.log(`Updated membership status for ${ usersToUpdate.length } users`);
}

connect();
route(app);

server.listen(port, () => {
    console.log(`listen on http://localhost:${ port }`);
});
